<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV to XML Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 32px 16px;
            color: #111;
        }

        body:not(.authenticated) .container {
            display: none;
        }

        .login-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000, #333);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        body.authenticated .login-screen {
            display: none;
        }

        .login-card {
            background: #fff;
            border-radius: 20px;
            padding: 32px;
            width: 100%;
            max-width: 420px;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.35);
            border: 1px solid #e0e0e0;
        }

        .login-card h2 {
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 18px;
        }

        .login-card label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            margin-top: 12px;
        }

        .login-card input {
            width: 100%;
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid #d1d1d1;
            font-size: 14px;
        }

        .login-card button {
            width: 100%;
            margin-top: 20px;
        }

        .login-error {
            margin-top: 12px;
            color: #c53030;
            font-size: 13px;
            min-height: 18px;
        }

        body.partner-role #uploadSectionContainer {
            display: none;
        }

        .admin-only {
            display: none;
        }

        body.admin-role .admin-only {
            display: inline-flex;
        }

        .container {
            max-width: 840px;
            margin: 0 auto;
            background: #fff;
            border-radius: 18px;
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.15);
            padding: 48px;
            border: 1px solid #e0e0e0;
        }

        h1 {
            color: #111;
            margin-bottom: 8px;
            font-size: 32px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .subtitle {
            color: #555;
            margin-bottom: 32px;
            font-size: 16px;
        }

        .upload-section {
            margin-bottom: 24px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .upload-label {
            color: #111;
            font-weight: 600;
            font-size: 13px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .control-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 10px;
        }

        .panel {
            flex: 1;
            min-width: 260px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 18px;
            padding: 20px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, 0.1);
        }

        .panel h3 {
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 14px;
        }

        .file-input-wrapper {
            position: relative;
            width: 100%;
        }

        .file-input {
            width: 100%;
            padding: 16px;
            border: 1px solid #d1d1d1;
            border-radius: 16px;
            font-size: 15px;
            letter-spacing: 0.3px;
            background: #fff;
            color: transparent;
            cursor: pointer;
            transition: border 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.08);
        }

        .file-input:hover {
            border-color: #111;
            box-shadow: 0 14px 28px rgba(0, 0, 0, 0.1);
        }

        .file-input:focus {
            outline: none;
            border-color: #000;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
        }

        .file-input::file-selector-button {
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            background: #111;
            color: #fff;
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 0.4px;
            cursor: pointer;
            margin-right: 20px;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        .file-input::file-selector-button:hover {
            background: #000;
            transform: translateY(-1px);
        }

        .file-input::file-selector-button:active {
            transform: translateY(0);
        }

        .file-name {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
            color: #555;
            pointer-events: none;
            max-width: calc(100% - 160px);
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
        }

        .file-status {
            font-size: 13px;
            color: #0f9d58;
            display: none;
        }

        .file-status.show {
            display: block;
        }

        .action-panel {
            margin-top: 32px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 18px;
            padding: 24px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.1);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 14px;
            width: 100%;
        }

        .btn {
            padding: 14px 18px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid transparent;
            background: #000;
            color: #fff;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            flex: 1;
            min-width: 180px;
        }

        .generate-btn {
            width: 100%;
            margin-top: 18px;
        }

        .btn-primary {
            background: #111;
            border-color: #111;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }

        .btn-secondary {
            background: #fff;
            color: #111;
            border-color: #111;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #111;
            color: #fff;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
        }

        .preview {
            margin-top: 32px;
            padding: 20px;
            background: #fafafa;
            border-radius: 12px;
            border: 1px solid #e0e0e0;
            max-height: 420px;
            overflow-y: auto;
            display: none;
        }

        .preview.show {
            display: block;
        }

        .preview h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .preview pre {
            background: white;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.6;
            color: #2d3748;
            border: 1px solid #e2e8f0;
        }

        .alert {
            padding: 16px 18px;
            border-radius: 12px;
            margin-top: 16px;
            display: none;
            border: 1px solid transparent;
        }

        .alert.show {
            display: block;
        }

        .error {
            background: #fff5f5;
            border-color: #f44336;
            color: #b71c1c;
        }

        .success {
            background: #f3fff6;
            border-color: #00a152;
            color: #00733a;
        }

        .info-box {
            background: #111;
            color: #f5f5f5;
            padding: 20px;
            border-radius: 14px;
            margin-bottom: 28px;
            font-size: 14px;
            line-height: 1.6;
            letter-spacing: 0.3px;
        }

        .info-box strong {
            display: block;
            margin-bottom: 8px;
            font-size: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .progress-container {
            margin-top: 28px;
            display: none;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 18px;
        }

        .progress-container.show {
            display: block;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            color: #222;
            font-weight: 500;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e5e5e5;
            border-radius: 999px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #000, #555);
            transition: width 0.3s ease;
            border-radius: 999px;
        }

        .progress-text {
            margin-top: 8px;
            font-size: 13px;
            color: #555;
        }

        .search-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d1d1;
            border-radius: 12px;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .family-toolbar,
        .settings-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .mini-btn {
            padding: 8px 14px;
            border-radius: 10px;
            border: 1px solid #111;
            background: #fff;
            color: #111;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            cursor: pointer;
        }

        .mini-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .mini-btn.primary {
            background: #111;
            color: #fff;
        }

        .family-list {
            max-height: 220px;
            overflow-y: auto;
            border: 1px solid #ededed;
            border-radius: 14px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: #fafafa;
        }

        .family-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #222;
        }

        .checkbox-control {
            width: 18px;
            height: 18px;
            min-width: 18px;
            min-height: 18px;
            border: 2px solid #111;
            border-radius: 4px;
            background: #fff;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .checkbox-control:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
        }

        .checkbox-control:checked {
            background: #111;
        }

        .checkbox-control:checked::after {
            content: '';
            width: 6px;
            height: 10px;
            border-right: 2px solid #fff;
            border-bottom: 2px solid #fff;
            transform: rotate(45deg);
            margin-top: -2px;
        }

        .info-text {
            font-size: 13px;
            color: #555;
            margin-bottom: 10px;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
            margin-bottom: 12px;
        }

        .settings-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .empty-state {
            text-align: center;
            font-size: 13px;
            color: #888;
            padding: 20px 0;
        }
    </style>
</head>

<body>
    <div class="login-screen" id="loginScreen">
        <div class="login-card">
            <h2>Авторизація</h2>
            <form id="loginForm">
                <label for="usernameInput">Логін</label>
                <input type="text" id="usernameInput" autocomplete="username" placeholder="Введіть логін" required>
                <label for="passwordInput">Пароль</label>
                <input type="password" id="passwordInput" autocomplete="current-password" placeholder="Введіть пароль"
                    required>
                <button type="submit" class="btn btn-primary">Увійти</button>
                <div class="login-error" id="loginError"></div>
            </form>
        </div>
    </div>
    <div class="container">
        <h1>CSV to XML Converter</h1>
        <p class="subtitle">Завантажте 3 CSV файли для генерації XML</p>

        <div id="uploadSectionContainer">
            <div class="upload-section">
                <label class="upload-label">1. Файл Фемілі -- export_Export_family_csv</label>
                <div class="file-input-wrapper">
                    <input type="file" id="familyFile" accept=".csv" class="file-input">
                    <span class="file-name" id="familyFileName">Файл не вибрано</span>
                </div>
                <div class="file-status" id="familyStatus">✓ Файл завантажено</div>
            </div>

            <div class="upload-section">
                <label class="upload-label">2. Файл Атрибутів -- export_Export_attribute_csv</label>
                <div class="file-input-wrapper">
                    <input type="file" id="attributesFile" accept=".csv" class="file-input">
                    <span class="file-name" id="attributesFileName">Файл не вибрано</span>
                </div>
                <div class="file-status" id="attributesStatus">✓ Файл завантажено</div>
            </div>

            <div class="upload-section">
                <label class="upload-label">3. Файл Значень Атрибутів -- export_Export_attribute_OPTION_csv</label>
                <div class="file-input-wrapper">
                    <input type="file" id="valuesFile" accept=".csv" class="file-input">
                    <span class="file-name" id="valuesFileName">Файл не вибрано</span>
                </div>
                <div class="file-status" id="valuesStatus">✓ Файл завантажено</div>
            </div>

            <button class="mini-btn primary admin-only" id="saveEmbeddedBtn" style="margin-top:12px;">Зберегти вбудовані
                дані</button>
        </div>

        <div class="control-grid">
            <div class="panel family-panel">
                <h3>Фільтр фемілі</h3>
                <input type="text" id="familySearchInput" class="search-input" placeholder="Пошук за назвою або кодом"
                    disabled>
                <div class="family-toolbar">
                    <button class="mini-btn primary" id="familySelectAllBtn" disabled>Обрати всі</button>
                    <button class="mini-btn" id="familyClearBtn" disabled>Очистити вибір</button>
                </div>
                <div class="info-text" id="familySelectionInfo">Завантажте файл фемілі, щоб сформувати список.</div>
                <div class="family-list" id="familyList">
                    <div class="empty-state">Список порожній</div>
                </div>
            </div>

            <div class="panel settings-panel">
                <h3>Налаштування полів</h3>
                <div class="settings-grid" id="settingsGrid"></div>
                <div class="settings-actions">
                    <button class="mini-btn primary" id="settingsSelectAllBtn">Обрати всі</button>
                    <button class="mini-btn" id="settingsClearBtn">Очистити</button>
                </div>
                <p class="info-text">Обрані поля потраплять у XML, CSV та XLSX.</p>
            </div>

        </div>

        <div class="action-panel">
            <div class="button-group">
                <button class="btn btn-secondary" id="downloadCsvBtn" disabled>Експорт CSV</button>
                <button class="btn btn-secondary" id="downloadXlsxBtn" disabled>Експорт XLSX</button>
                <button class="btn btn-secondary" id="downloadBtn" disabled>Експорт XML</button>
            </div>
            <button class="btn btn-primary generate-btn" id="generateBtn" disabled>Згенерувати</button>
            <div class="alert error" id="errorMsg"></div>
            <div class="alert success" id="successMsg"></div>
        </div>

        <div class="progress-container" id="progressContainer">
            <div class="progress-label">
                <span>Генерація XML...</span>
                <span id="progressPercent">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Обробка фемілії 0...</div>
        </div>

        <div class="preview" id="preview">
            <h3>Попередній перегляд XML:</h3>
            <pre id="xmlContent"></pre>
        </div>
    </div>

    <script>
        let familyData = null;
        let attributesData = null;
        let valuesData = null;
        let generatedXMLBlob = null;
        let generatedXMLFileName = 'output.xml';
        const PREVIEW_CHAR_LIMIT = 20000;
        const EXCLUDED_GROUPS = new Set(['erp', 'marketing', 'other', 'photo_gallery']);
        const loggedAttributeIssues = new Set();
        const ATTRIBUTE_TYPE_LABELS = {
            'pim_catalog_text': 'Текст до 255 символів',
            'pim_catalog_textarea': 'Текстове поле',
            'pim_catalog_number': 'Число',
            'pim_catalog_boolean': 'Так/Ні',
            'pim_catalog_multiselect': 'Мультиселект',
            'pim_catalog_simpleselect': 'Сімплселект'
        };
        const EMBEDDED_FAMILY_DATA = [
            { code: 'smartphones', 'label-uk_UA': 'Смартфони', attributes: 'brand,smartphones_operating_system,smartphones_ram_amount' },
            { code: 'portable_powerplants', 'label-uk_UA': 'Портативні електростанції', attributes: 'brand,portable_capacity,power_output' }
        ];
        const EMBEDDED_ATTRIBUTE_DATA = [
            { code: 'brand', 'label-uk_UA': 'Бренд', type: 'pim_catalog_simpleselect', group: 'general' },
            { code: 'smartphones_operating_system', 'label-uk_UA': 'Операційна система', type: 'pim_catalog_simpleselect', group: 'additionally' },
            { code: 'smartphones_ram_amount', 'label-uk_UA': 'Оперативна памʼять, ГБ', type: 'pim_catalog_number', group: 'technical' },
            { code: 'portable_capacity', 'label-uk_UA': 'Ємність батареї, Вт·год', type: 'pim_catalog_number', group: 'technical' },
            { code: 'power_output', 'label-uk_UA': 'Пікова потужність, Вт', type: 'pim_catalog_number', group: 'technical' }
        ];
        const EMBEDDED_VALUE_DATA = [
            { code: 'apple', 'label-uk_UA': 'Apple', attribute: 'brand' },
            { code: 'samsung', 'label-uk_UA': 'Samsung', attribute: 'brand' },
            { code: 'android', 'label-uk_UA': 'Android', attribute: 'smartphones_operating_system' },
            { code: 'ios', 'label-uk_UA': 'iOS', attribute: 'smartphones_operating_system' },
            { code: 'ram_8', 'label-uk_UA': '8', attribute: 'smartphones_ram_amount' },
            { code: 'ram_12', 'label-uk_UA': '12', attribute: 'smartphones_ram_amount' },
            { code: 'cap_512', 'label-uk_UA': '512', attribute: 'portable_capacity' },
            { code: 'cap_1024', 'label-uk_UA': '1024', attribute: 'portable_capacity' },
            { code: 'power_800', 'label-uk_UA': '800', attribute: 'power_output' },
            { code: 'power_1200', 'label-uk_UA': '1200', attribute: 'power_output' }
        ];
        const DATA_FILES = {
            families: 'data/families.json',
            attributes: 'data/attributes.json',
            values: 'data/values.json'
        };
        const EXPORT_COLUMNS = [
            { key: 'familyCode', label: 'Код фемілі' },
            { key: 'familyLabel', label: 'Назва фемілі' },
            { key: 'attributeCode', label: 'Код атрибуту' },
            { key: 'attributeLabel', label: 'Назва атрибуту' },
            { key: 'attributeType', label: 'Тип атрибуту' },
            { key: 'valueCode', label: 'Код значення' },
            { key: 'valueLabel', label: 'Значення' }
        ];
        const EXCLUDED_ATTRIBUTE_LABELS = new Set([
            'офер цього товару в мастеркартці',
            'контент від партнера',
            'статус картки товару'
        ]);
        const INDENT = '  ';
        const DEFAULT_FILE_PLACEHOLDER = 'Файл не вибрано';
        const CRC32_TABLE = (() => {
            const table = [];
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let k = 0; k < 8; k++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                table[i] = c >>> 0;
            }
            return table;
        })();
        const textEncoder = new TextEncoder();
        const USERS = [
            { username: 'admin', password: 'admin123', role: 'admin' },
            { username: 'partner', password: 'partner123', role: 'partner' }
        ];
        let currentRole = null;
        const loginForm = document.getElementById('loginForm');
        const loginError = document.getElementById('loginError');
        const usernameInput = document.getElementById('usernameInput');
        const passwordInput = document.getElementById('passwordInput');
        let attributeMap = new Map();
        let valuesMap = new Map();
        let exportRows = [];
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadCsvBtn = document.getElementById('downloadCsvBtn');
        const downloadXlsxBtn = document.getElementById('downloadXlsxBtn');
        const familyListContainer = document.getElementById('familyList');
        const familySearchInput = document.getElementById('familySearchInput');
        const familySelectAllBtn = document.getElementById('familySelectAllBtn');
        const familyClearBtn = document.getElementById('familyClearBtn');
        const familySelectionInfo = document.getElementById('familySelectionInfo');
        const settingsGrid = document.getElementById('settingsGrid');
        const settingsSelectAllBtn = document.getElementById('settingsSelectAllBtn');
        const settingsClearBtn = document.getElementById('settingsClearBtn');
        const saveEmbeddedBtn = document.getElementById('saveEmbeddedBtn');
        let familyListData = [];
        let selectedFamilyCodes = new Set();
        let familySearchTerm = '';
        let activeFamilies = [];
        const exportSettings = EXPORT_COLUMNS.reduce((acc, col) => {
            acc[col.key] = true;
            return acc;
        }, {});

        function parseCSV(text) {
            const rows = [];
            let current = '';
            let row = [];
            let inQuotes = false;

            const pushField = () => {
                row.push(current);
                current = '';
            };

            const pushRow = () => {
                // Skip completely empty rows
                if (row.length === 1 && row[0].trim() === '') {
                    row = [];
                    return;
                }
                rows.push(row);
                row = [];
            };

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];

                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ';' && !inQuotes) {
                    pushField();
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    pushField();
                    pushRow();

                    if (char === '\r' && nextChar === '\n') {
                        i++;
                    }
                } else {
                    current += char;
                }
            }

            pushField();
            if (row.length > 1 || (row.length === 1 && row[0].trim() !== '')) {
                pushRow();
            }

            if (rows.length === 0) {
                return { headers: [], data: [] };
            }

            const headers = rows[0].map((header, index) => {
                const cleaned = header.replace(/^\uFEFF/, '').trim();
                return cleaned || `column_${index}`;
            });
            const data = [];

            for (let i = 1; i < rows.length; i++) {
                const values = rows[i];
                const entry = {};
                headers.forEach((header, index) => {
                    entry[header] = (values[index] !== undefined ? values[index] : '').trim();
                });
                data.push(entry);
            }

            return { headers, data };
        }

        function handleFileUpload(fileInput, statusElement, dataVariable) {
            return new Promise((resolve, reject) => {
                const file = fileInput.files[0];
                if (!file) {
                    resolve(null);
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const parsed = parseCSV(e.target.result);
                        statusElement.classList.add('show');
                        resolve(parsed);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error('Помилка читання файлу'));
                reader.readAsText(file, 'UTF-8');
            });
        }

        function getFieldValue(record, fieldName) {
            if (!record) return '';
            const target = (fieldName || '').trim().toLowerCase();
            for (const key in record) {
                if (!Object.prototype.hasOwnProperty.call(record, key)) continue;
                const normalizedKey = (key || '').trim().toLowerCase();
                if (normalizedKey === target) {
                    return record[key] || '';
                }
            }
            return '';
        }

        function cleanValue(value, toLower = false) {
            if (!value) return '';
            let cleaned = String(value).trim();
            if ((cleaned.startsWith('"') && cleaned.endsWith('"')) || (cleaned.startsWith("'") && cleaned.endsWith("'"))) {
                cleaned = cleaned.slice(1, -1);
            }
            return toLower ? cleaned.toLowerCase() : cleaned;
        }

        function getValueLabel(value) {
            if (!value) return '';
            return cleanValue(getFieldValue(value, 'label-uk_UA') || value['label-uk_UA'] || value.label || '');
        }

        function logAttributeIssue(code, reason, attribute = null) {
            const key = `${code}:${reason}`;
            if (loggedAttributeIssues.has(key)) {
                return;
            }
            loggedAttributeIssues.add(key);
            const normalizedType = attribute ? getAttributeType(attribute) : '';
            const originalType = attribute && attribute.original ? getFieldValue(attribute.original, 'type') : '';
            console.warn(
                `[XML DEBUG] ${reason} | code=${code} | normalizedType="${normalizedType}" | originalType="${originalType}"`
            );
            if (attribute && attribute.original) {
                console.warn('[XML DEBUG] raw attribute record:', attribute.original);
            }
        }

        function getActiveColumns() {
            return EXPORT_COLUMNS.filter(col => exportSettings[col.key]);
        }

        function renderSettingsControls() {
            if (!settingsGrid) return;
            settingsGrid.innerHTML = '';
            EXPORT_COLUMNS.forEach(column => {
                const wrapper = document.createElement('label');
                wrapper.className = 'settings-item';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'checkbox-control';
                checkbox.checked = !!exportSettings[column.key];
                checkbox.addEventListener('change', () => {
                    exportSettings[column.key] = checkbox.checked;
                    updateExportButtonsState();
                });
                const text = document.createElement('span');
                text.textContent = column.label;
                wrapper.appendChild(checkbox);
                wrapper.appendChild(text);
                settingsGrid.appendChild(wrapper);
            });
        }

        function updateFamilySelectionInfo() {
            if (!familySelectionInfo) return;
            const total = familyListData.length;
            if (!total) {
                familySelectionInfo.textContent = 'Завантажте файл фемілі, щоб сформувати список.';
                familySearchInput.disabled = true;
                familySelectAllBtn.disabled = true;
                familyClearBtn.disabled = true;
                return;
            }
            familySearchInput.disabled = false;
            familySelectAllBtn.disabled = false;
            familyClearBtn.disabled = false;
            const selected = selectedFamilyCodes.size;
            familySelectionInfo.textContent = `Обрано ${selected} з ${total} фемілій`;
        }

        function renderFamilyList() {
            if (!familyListContainer) return;
            familyListContainer.innerHTML = '';
            if (!familyListData.length) {
                familyListContainer.innerHTML = '<div class="empty-state">Список порожній</div>';
                return;
            }
            const term = familySearchTerm.trim().toLowerCase();
            const filtered = familyListData
                .filter(item => {
                    return (
                        item.label.toLowerCase().includes(term) ||
                        item.code.toLowerCase().includes(term)
                    );
                })
                .sort((a, b) => {
                    const aSelected = selectedFamilyCodes.has(a.code) ? 1 : 0;
                    const bSelected = selectedFamilyCodes.has(b.code) ? 1 : 0;
                    if (aSelected !== bSelected) return bSelected - aSelected;
                    return a.label.localeCompare(b.label, 'uk', { sensitivity: 'base' });
                });
            if (!filtered.length) {
                familyListContainer.innerHTML = '<div class="empty-state">Нічого не знайдено</div>';
                return;
            }

            filtered.forEach(item => {
                const label = document.createElement('label');
                label.className = 'family-item';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'checkbox-control';
                checkbox.value = item.code;
                checkbox.checked = selectedFamilyCodes.has(item.code);
                checkbox.addEventListener('change', (event) => {
                    if (event.target.checked) {
                        selectedFamilyCodes.add(item.code);
                    } else {
                        selectedFamilyCodes.delete(item.code);
                    }
                    updateFamilySelectionInfo();
                });
                const text = document.createElement('span');
                text.textContent = `${item.label} (${item.code})`;
                label.appendChild(checkbox);
                label.appendChild(text);
                familyListContainer.appendChild(label);
            });
        }

        function prepareFamilySelection() {
            if (!familyData || !familyData.data.length) {
                familyListData = [];
                selectedFamilyCodes.clear();
                familySearchTerm = '';
                if (familySearchInput) familySearchInput.value = '';
                renderFamilyList();
                updateFamilySelectionInfo();
                return;
            }

            const uniqueMap = new Map();
            familyData.data.forEach(family => {
                const code = cleanValue(family.code || '');
                if (!code || uniqueMap.has(code)) return;
                const label = normalizeLabel(family['label-uk_UA']) || '(без назви)';
                uniqueMap.set(code, { code, label });
            });
            familyListData = Array.from(uniqueMap.values());

            selectedFamilyCodes = new Set(familyListData.map(item => item.code));
            familySearchTerm = '';
            if (familySearchInput) familySearchInput.value = '';
            renderFamilyList();
            updateFamilySelectionInfo();
        }

        function getFilteredFamilies() {
            if (!familyData || !familyData.data.length) return [];
            if (selectedFamilyCodes.size === 0) return [];
            if (selectedFamilyCodes.size === familyListData.length) {
                return familyData.data;
            }
            return familyData.data.filter(family => {
                const code = cleanValue(family.code || '');
                return selectedFamilyCodes.has(code);
            });
        }

        function buildEmbeddedPayload() {
            if (!familyData || !attributesData || !valuesData) {
                return { families: [], attributes: [], values: [] };
            }
            if (!selectedFamilyCodes.size) {
                return { families: [], attributes: [], values: [] };
            }

            const familiesRaw = getFilteredFamilies();
            if (!familiesRaw.length) {
                return { families: [], attributes: [], values: [] };
            }

            const attributeCodes = new Set();
            const families = familiesRaw.map(family => {
                const code = cleanValue(family.code || '');
                const attrs = (family.attributes || '')
                    .split(',')
                    .map(attr => cleanValue(attr))
                    .filter(Boolean);
                attrs.forEach(attr => attributeCodes.add(attr));
                return {
                    code,
                    'label-uk_UA': family['label-uk_UA'] || '',
                    attributes: attrs.join(',')
                };
            });

            const attributes = attributesData.data
                .filter(attr => {
                    const code = cleanValue(attr.code || '');
                    if (!code || !attributeCodes.has(code)) return false;
                    const label = normalizeLabel(attr['label-uk_UA'] || '').toLowerCase();
                    if (EXCLUDED_ATTRIBUTE_LABELS.has(label)) return false;
                    return true;
                })
                .map(attr => ({
                    code: cleanValue(attr.code || ''),
                    'label-uk_UA': attr['label-uk_UA'] || '',
                    type: attr.type || '',
                    group: attr.group || ''
                }));

            const allowedAttributeCodes = new Set(attributes.map(attr => attr.code));
            const values = valuesData.data
                .filter(value => allowedAttributeCodes.has(cleanValue(value.attribute || '')))
                .map(value => ({
                    code: cleanValue(value.code || ''),
                    'label-uk_UA': value['label-uk_UA'] || '',
                    attribute: cleanValue(value.attribute || '')
                }));

            return { families, attributes, values };
        }

        function cloneEmbeddedData(data) {
            return data.map(item => ({ ...item }));
        }

        function markEmbeddedStatus(source = 'embedded') {
            ['family', 'attributes', 'values'].forEach(prefix => {
                const statusEl = document.getElementById(`${prefix}Status`);
                const nameEl = document.getElementById(`${prefix}FileName`);
                if (statusEl) {
                    statusEl.textContent = '✓ Використовується вбудований набір';
                    statusEl.classList.add('show');
                }
                if (nameEl) {
                    nameEl.textContent = source === 'remote'
                        ? 'Файл data/' + prefix + '.json'
                        : 'Вбудовані дані';
                }
            });
        }

        function useEmbeddedData() {
            familyData = { headers: [], data: cloneEmbeddedData(EMBEDDED_FAMILY_DATA) };
            attributesData = { headers: [], data: cloneEmbeddedData(EMBEDDED_ATTRIBUTE_DATA) };
            valuesData = { headers: [], data: cloneEmbeddedData(EMBEDDED_VALUE_DATA) };
            exportRows = [];
            markEmbeddedStatus('embedded');
            checkAllFilesLoaded();
        }

        async function loadRemoteData() {
            const fetchJson = async (url) => {
                const response = await fetch(url, { cache: 'no-cache' });
                if (!response.ok) {
                    throw new Error(`Не вдалося завантажити ${url}`);
                }
                return response.json();
            };

            const [families, attributes, values] = await Promise.all([
                fetchJson(DATA_FILES.families),
                fetchJson(DATA_FILES.attributes),
                fetchJson(DATA_FILES.values)
            ]);

            familyData = { headers: [], data: families };
            attributesData = { headers: [], data: attributes };
            valuesData = { headers: [], data: values };
            exportRows = [];
            markEmbeddedStatus('remote');
            checkAllFilesLoaded();
        }

        let dataInitPromise = null;
        function initializeData() {
            if (dataInitPromise) return dataInitPromise;
            dataInitPromise = loadRemoteData().catch((error) => {
                console.warn('Fallback to embedded data:', error);
                useEmbeddedData();
            });
            return dataInitPromise;
        }
        function getAttributeLabel(attribute) {
            if (!attribute) return '';
            if (attribute.label) return attribute.label;
            if (attribute.original) {
                return cleanValue(getFieldValue(attribute.original, 'label-uk_ua'));
            }
            return '';
        }

        function getAttributeType(attribute) {
            if (!attribute) return '';
            if (attribute.type) return attribute.type;
            if (attribute.original) {
                return cleanValue(getFieldValue(attribute.original, 'type'), true);
            }
            return '';
        }

        function appendExportRows(family, attribute, values) {
            if (!family || !attribute) return;
            const familyCode = cleanValue(family.code || '');
            const familyLabel = normalizeLabel(family['label-uk_UA']);
            const attributeCode = attribute.code || '';
            const attributeLabel = normalizeLabel(getAttributeLabel(attribute));
            if (EXCLUDED_ATTRIBUTE_LABELS.has(attributeLabel.toLowerCase())) {
                return;
            }
            const attributeTypeRaw = getAttributeType(attribute);
            const attributeType = getAttributeTypeLabel(attributeTypeRaw) || attributeTypeRaw || '';

            if (values && values.length > 0) {
                for (const value of values) {
                    exportRows.push({
                        familyCode,
                        familyLabel,
                        attributeCode,
                        attributeLabel,
                        attributeType,
                        valueCode: cleanValue(value.code || ''),
                        valueLabel: getValueLabel(value)
                    });
                }
            } else {
                exportRows.push({
                    familyCode,
                    familyLabel,
                    attributeCode,
                    attributeLabel,
                    attributeType,
                    valueCode: '',
                    valueLabel: ''
                });
            }
        }

        function crc32(buffer) {
            let crc = 0 ^ (-1);
            for (let i = 0; i < buffer.length; i++) {
                crc = (crc >>> 8) ^ CRC32_TABLE[(crc ^ buffer[i]) & 0xFF];
            }
            return (crc ^ (-1)) >>> 0;
        }

        function columnLetter(index) {
            let letters = '';
            let current = index;
            while (current > 0) {
                const remainder = (current - 1) % 26;
                letters = String.fromCharCode(65 + remainder) + letters;
                current = Math.floor((current - 1) / 26);
            }
            return letters;
        }

        function buildWorksheetXML(rows, columns) {
            const allRows = [
                columns.map(col => col.label),
                ...rows.map(row => columns.map(col => row[col.key] || ''))
            ];
            let xml = '<?xml version="1.0" encoding="UTF-8"?>';
            xml += '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">';
            xml += '<sheetData>';
            allRows.forEach((rowValues, rowIndex) => {
                const excelRow = rowIndex + 1;
                xml += `<row r="${excelRow}">`;
                rowValues.forEach((value, colIndex) => {
                    const cellRef = `${columnLetter(colIndex + 1)}${excelRow}`;
                    xml += `<c r="${cellRef}" t="inlineStr"><is><t>${escapeXml(value || '')}</t></is></c>`;
                });
                xml += '</row>';
            });
            xml += '</sheetData></worksheet>';
            return xml;
        }

        function createZip(files) {
            const chunks = [];
            const entries = [];
            let offset = 0;

            for (const file of files) {
                const content = typeof file.content === 'string' ? textEncoder.encode(file.content) : file.content;
                const nameBytes = textEncoder.encode(file.name);
                const crc = crc32(content);
                const localHeader = new Uint8Array(30 + nameBytes.length);
                const headerView = new DataView(localHeader.buffer);

                headerView.setUint32(0, 0x04034b50, true);
                headerView.setUint16(4, 20, true);
                headerView.setUint16(6, 0, true);
                headerView.setUint16(8, 0, true);
                headerView.setUint16(10, 0, true);
                headerView.setUint16(12, 0, true);
                headerView.setUint32(14, crc, true);
                headerView.setUint32(18, content.length, true);
                headerView.setUint32(22, content.length, true);
                headerView.setUint16(26, nameBytes.length, true);
                headerView.setUint16(28, 0, true);
                localHeader.set(nameBytes, 30);

                chunks.push(localHeader, content);
                entries.push({
                    nameBytes,
                    content,
                    crc,
                    offset,
                    size: content.length
                });
                offset += localHeader.length + content.length;
            }

            const centralOffset = offset;
            let centralSize = 0;
            for (const entry of entries) {
                const centralHeader = new Uint8Array(46 + entry.nameBytes.length);
                const centralView = new DataView(centralHeader.buffer);
                centralView.setUint32(0, 0x02014b50, true);
                centralView.setUint16(4, 20, true);
                centralView.setUint16(6, 20, true);
                centralView.setUint16(8, 0, true);
                centralView.setUint16(10, 0, true);
                centralView.setUint16(12, 0, true);
                centralView.setUint16(14, 0, true);
                centralView.setUint32(16, entry.crc, true);
                centralView.setUint32(20, entry.size, true);
                centralView.setUint32(24, entry.size, true);
                centralView.setUint16(28, entry.nameBytes.length, true);
                centralView.setUint16(30, 0, true);
                centralView.setUint16(32, 0, true);
                centralView.setUint16(34, 0, true);
                centralView.setUint16(36, 0, true);
                centralView.setUint32(38, 0, true);
                centralView.setUint32(42, entry.offset, true);
                centralHeader.set(entry.nameBytes, 46);

                chunks.push(centralHeader);
                centralSize += centralHeader.length;
            }

            const endRecord = new Uint8Array(22);
            const endView = new DataView(endRecord.buffer);
            endView.setUint32(0, 0x06054b50, true);
            endView.setUint16(4, 0, true);
            endView.setUint16(6, 0, true);
            endView.setUint16(8, entries.length, true);
            endView.setUint16(10, entries.length, true);
            endView.setUint32(12, centralSize, true);
            endView.setUint32(16, centralOffset, true);
            endView.setUint16(20, 0, true);

            chunks.push(endRecord);
            return new Blob(chunks, { type: 'application/zip' });
        }

        function createXlsxBlob(rows, columns) {
            const sheetXml = buildWorksheetXML(rows, columns);
            const files = [
                {
                    name: '[Content_Types].xml',
                    content: '<?xml version="1.0" encoding="UTF-8"?>' +
                        '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">' +
                        '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>' +
                        '<Default Extension="xml" ContentType="application/xml"/>' +
                        '<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>' +
                        '<Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>' +
                        '</Types>'
                },
                {
                    name: '_rels/.rels',
                    content: '<?xml version="1.0" encoding="UTF-8"?>' +
                        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' +
                        '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>' +
                        '</Relationships>'
                },
                {
                    name: 'xl/workbook.xml',
                    content: '<?xml version="1.0" encoding="UTF-8"?>' +
                        '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">' +
                        '<sheets><sheet name="Data" sheetId="1" r:id="rId1"/></sheets></workbook>'
                },
                {
                    name: 'xl/_rels/workbook.xml.rels',
                    content: '<?xml version="1.0" encoding="UTF-8"?>' +
                        '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' +
                        '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>' +
                        '</Relationships>'
                },
                {
                    name: 'xl/worksheets/sheet1.xml',
                    content: sheetXml
                }
            ];
            return createZip(files);
        }

        function rowsToCSV(rows, columns) {
            const lines = [];
            const headerLine = columns.map(col => `"${col.label.replace(/"/g, '""')}"`).join(';');
            lines.push(headerLine);
            rows.forEach(row => {
                const line = columns.map(col => {
                    const value = (row[col.key] || '').toString().replace(/"/g, '""');
                    return `"${value}"`;
                }).join(';');
                lines.push(line);
            });
            return lines.join('\n');
        }

        function triggerDownload(blob, filename) {
            const url = URL.createObjectURL(blob);
            const anchor = document.createElement('a');
            anchor.href = url;
            anchor.download = filename;
            document.body.appendChild(anchor);
            anchor.click();
            document.body.removeChild(anchor);
            URL.revokeObjectURL(url);
        }

        function downloadCsvFile() {
            const columns = getActiveColumns();
            if (!columns.length) {
                showError('Оберіть щонайменше одне поле у налаштуваннях');
                return;
            }
            if (!exportRows.length) {
                showError('Немає даних для експорту CSV');
                return;
            }
            const csvContent = rowsToCSV(exportRows, columns);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
            triggerDownload(blob, 'families.csv');
            showSuccess('CSV файл сформовано');
        }

        function downloadXlsxFile() {
            const columns = getActiveColumns();
            if (!columns.length) {
                showError('Оберіть щонайменше одне поле у налаштуваннях');
                return;
            }
            if (!exportRows.length) {
                showError('Немає даних для експорту XLSX');
                return;
            }
            const blob = createXlsxBlob(exportRows, columns);
            triggerDownload(blob, 'families.xlsx');
            showSuccess('XLSX файл сформовано');
        }

        function downloadEmbeddedDataFile() {
            const payload = buildEmbeddedPayload();
            if (!payload.families.length) {
                showError('Оберіть фемілії для формування даних');
                return;
            }

            const datasets = [
                { filename: 'families.json', data: payload.families },
                { filename: 'attributes.json', data: payload.attributes },
                { filename: 'values.json', data: payload.values }
            ];

            let downloaded = 0;
            for (const { filename, data } of datasets) {
                if (!data.length) continue;
                const blob = new Blob(
                    [JSON.stringify(data, null, 2)],
                    { type: 'application/json;charset=utf-8' }
                );
                triggerDownload(blob, filename);
                downloaded++;
            }

            if (!downloaded) {
                showError('Для вибраних фемілій немає даних атрибутів або значень');
                return;
            }

            showSuccess('JSON файли збережено. Завантаж їх у папку data/');
        }

        function checkAllFilesLoaded() {
            const hasFamilies = familyData && Array.isArray(familyData.data) && familyData.data.length > 0;
            const hasAttributes = attributesData && Array.isArray(attributesData.data) && attributesData.data.length > 0;
            const hasValues = valuesData && Array.isArray(valuesData.data) && valuesData.data.length > 0;
            const ready = hasFamilies && hasAttributes && hasValues;

            document.getElementById('generateBtn').disabled = !ready;
            downloadBtn.disabled = !generatedXMLBlob;

            if (ready) {
                buildAttributeMap();
                buildValuesMap();
                prepareFamilySelection();
                updateExportButtonsState();
            } else {
                updateFamilySelectionInfo();
                renderFamilyList();
            }
        }

        function showError(message) {
            const errorMsg = document.getElementById('errorMsg');
            errorMsg.textContent = message;
            errorMsg.classList.add('show');
            setTimeout(() => errorMsg.classList.remove('show'), 5000);
        }

        function showSuccess(message) {
            const successMsg = document.getElementById('successMsg');
            successMsg.textContent = message;
            successMsg.classList.add('show');
            setTimeout(() => successMsg.classList.remove('show'), 5000);
        }

        function updateExportButtonsState() {
            const hasData = exportRows.length > 0;
            const hasColumns = getActiveColumns().length > 0;
            downloadCsvBtn.disabled = !hasData || !hasColumns;
            downloadXlsxBtn.disabled = !hasData || !hasColumns;
        }

        function findAttributeByCode(code) {
            if (!code) return null;
            return attributeMap.get(code) || null;
        }

        function findValuesByAttributeCode(attributeCode) {
            if (!attributeCode) return [];
            return valuesMap.get(attributeCode) || [];
        }

        function buildAttributeMap() {
            attributeMap = new Map();
            if (!attributesData) return;

            for (const attr of attributesData.data) {
                const code = getFieldValue(attr, 'code').trim();
                if (!code) continue;

                const normalizedAttr = {
                    code,
                    label: cleanValue(getFieldValue(attr, 'label-uk_ua')),
                    type: cleanValue(getFieldValue(attr, 'type'), true),
                    group: cleanValue(getFieldValue(attr, 'group'), true),
                    original: attr
                };

                attributeMap.set(code, normalizedAttr);
            }
        }

        function buildValuesMap() {
            valuesMap = new Map();
            if (!valuesData) return;

            for (const val of valuesData.data) {
                const attrCode = (val.attribute || '').trim();
                if (!attrCode) continue;

                if (!valuesMap.has(attrCode)) {
                    valuesMap.set(attrCode, []);
                }
                valuesMap.get(attrCode).push(val);
            }
        }

        function escapeXml(unsafe) {
            if (!unsafe) return '';
            return unsafe
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        function normalizeLabel(text) {
            if (!text) return '';
            return text.replace(/"/g, '').trim();
        }

        function getAttributeTypeLabel(typeCode) {
            const code = (typeCode || '').trim();
            if (!code) return '';
            const key = code.toLowerCase();
            return ATTRIBUTE_TYPE_LABELS[key] || code;
        }

        function updateProgress(current, total, label) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progressPercent').textContent = percent + '%';
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = label;
        }

        function addLine(parts, level, content = '') {
            if (content === '') {
                parts.push('\n');
                return;
            }
            const indent = INDENT.repeat(Math.max(0, level));
            parts.push(indent + content + '\n');
        }

        function buildPreviewText(parts, limit = PREVIEW_CHAR_LIMIT) {
            if (!Array.isArray(parts) || parts.length === 0) return '';

            let remaining = typeof limit === 'number' && limit > 0 ? limit : PREVIEW_CHAR_LIMIT;
            const previewParts = [];
            let truncated = false;

            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (remaining <= 0) {
                    truncated = true;
                    break;
                }

                if (part.length <= remaining) {
                    previewParts.push(part);
                    remaining -= part.length;
                } else {
                    previewParts.push(part.slice(0, remaining));
                    truncated = true;
                    remaining = 0;
                    break;
                }
            }

            let preview = previewParts.join('');
            if (truncated) {
                preview += '\n... (попередній перегляд обрізано для швидкодії)';
            }
            return preview;
        }

        async function generateXML() {
            return new Promise((resolve, reject) => {
                try {
                    const includeFamilyCode = !!exportSettings.familyCode;
                    const includeFamilyLabel = !!exportSettings.familyLabel;
                    const includeAttributeCode = !!exportSettings.attributeCode;
                    const includeAttributeLabel = !!exportSettings.attributeLabel;
                    const includeAttributeType = !!exportSettings.attributeType;
                    const includeValueCode = !!exportSettings.valueCode;
                    const includeValueLabel = !!exportSettings.valueLabel;
                    const xmlParts = [];
                    addLine(xmlParts, 0, '<?xml version="1.0" encoding="UTF-8"?>');
                    addLine(xmlParts, 0, '<families>');

                    const families = activeFamilies.length ? activeFamilies : familyData.data;
                    const totalFamilies = families.length;
                    let currentIndex = 0;
                    const getNow = (typeof performance !== 'undefined' && performance.now)
                        ? () => performance.now()
                        : () => Date.now();

                    const processBatch = () => {
                        const batchStart = getNow();

                        while (currentIndex < totalFamilies && (getNow() - batchStart) < 16) {
                            const family = families[currentIndex];
                            const familyLabel = escapeXml(family['label-uk_UA']);
                            const familyCode = escapeXml(family.code);

                            let familyOpen = '<family';
                            if (includeFamilyCode) {
                                familyOpen += ` code="${familyCode}"`;
                            }
                            familyOpen += '>';
                            addLine(xmlParts, 1, familyOpen);
                            if (includeFamilyLabel) {
                                addLine(xmlParts, 2, `<label>${familyLabel}</label>`);
                            }
                            addLine(xmlParts, 2, '<attributes>');

                            const attributeCodes = family.attributes ? family.attributes.split(',').map(c => c.trim()) : [];

                            for (const attrCode of attributeCodes) {
                                if (!attrCode) continue;

                                const attribute = findAttributeByCode(attrCode);
                                if (!attribute) {
                                    logAttributeIssue(attrCode, 'Attribute not found in attributeMap');
                                    continue;
                                }

                                const attrLabelValue = getAttributeLabel(attribute);
                                const attrLabelPlain = normalizeLabel(attrLabelValue).toLowerCase();
                                if (EXCLUDED_ATTRIBUTE_LABELS.has(attrLabelPlain)) {
                                    continue;
                                }
                                const attrLabel = escapeXml(attrLabelValue || '');
                                const attrTypeValue = getAttributeType(attribute);
                                if (!attrTypeValue) {
                                    logAttributeIssue(attrCode, 'Attribute type is empty', attribute);
                                }
                                const attrTypeLabel = getAttributeTypeLabel(attrTypeValue) || attrTypeValue || 'Невідомий тип';
                                if (!ATTRIBUTE_TYPE_LABELS[attrTypeValue]) {
                                    logAttributeIssue(attrCode, 'Attribute type label not mapped', attribute);
                                }
                                const attrType = escapeXml(attrTypeLabel);

                                let attributeOpen = '<attribute';
                                if (includeAttributeCode) {
                                    attributeOpen += ` code="${escapeXml(attrCode)}"`;
                                }
                                if (includeAttributeType) {
                                    attributeOpen += ` type="${attrType}"`;
                                }
                                attributeOpen += '>';
                                addLine(xmlParts, 3, attributeOpen);
                                if (includeAttributeLabel) {
                                    addLine(xmlParts, 4, `<label>${attrLabel}</label>`);
                                }

                                const values = findValuesByAttributeCode(attrCode);
                                appendExportRows(family, attribute, values);
                                if (values.length > 0 && (includeValueCode || includeValueLabel)) {
                                    addLine(xmlParts, 4, '<options>');
                                    for (const value of values) {
                                        if (!includeValueCode && !includeValueLabel) {
                                            continue;
                                        }
                                        const valueLabel = escapeXml(value['label-uk_UA']);
                                        const valueCode = escapeXml(value.code);
                                        let optionLine = '<option';
                                        if (includeValueCode) {
                                            optionLine += ` code="${valueCode}"`;
                                        }
                                        optionLine += '>';
                                        if (includeValueLabel) {
                                            optionLine += valueLabel;
                                        }
                                        optionLine += '</option>';
                                        addLine(xmlParts, 5, optionLine);
                                    }
                                    addLine(xmlParts, 4, '</options>');
                                }

                                addLine(xmlParts, 3, '</attribute>');
                            }

                            addLine(xmlParts, 2, '</attributes>');
                            addLine(xmlParts, 1, '</family>');
                            if (currentIndex + 1 < totalFamilies) {
                                addLine(xmlParts, 0, '');
                            }

                            currentIndex++;
                            updateProgress(currentIndex, totalFamilies, `Обробка фемілії ${currentIndex} з ${totalFamilies}...`);
                        }

                        if (currentIndex < totalFamilies) {
                            setTimeout(processBatch, 0);
                        } else {
                            addLine(xmlParts, 0, '</families>');
                            updateProgress(totalFamilies, totalFamilies, `Оброблено ${totalFamilies} з ${totalFamilies}. Завершення...`);
                            resolve(xmlParts);
                        }
                    };

                    updateProgress(0, totalFamilies, `Обробка фемілії 0 з ${totalFamilies}...`);
                    processBatch();
                } catch (error) {
                    reject(new Error('Помилка генерації XML: ' + error.message));
                }
            });
        }

        async function generateFamilyAttributeXML() {
            return new Promise((resolve, reject) => {
                try {
                    const includeFamilyLabel = !!exportSettings.familyLabel;
                    const includeAttributeLabel = !!exportSettings.attributeLabel;
                    const includeAttributeType = !!exportSettings.attributeType;
                    const xmlParts = [];
                    addLine(xmlParts, 0, '<?xml version="1.0" encoding="UTF-8"?>');
                    addLine(xmlParts, 0, '<families>');

                    const families = activeFamilies.length ? activeFamilies : familyData.data;
                    const totalFamilies = families.length;
                    let currentIndex = 0;
                    const getNow = (typeof performance !== 'undefined' && performance.now)
                        ? () => performance.now()
                        : () => Date.now();

                    const processBatch = () => {
                        const batchStart = getNow();

                        while (currentIndex < totalFamilies && (getNow() - batchStart) < 16) {
                            const family = families[currentIndex];
                            const familyLabel = escapeXml(normalizeLabel(family['label-uk_UA']));

                            addLine(xmlParts, 1, '<family>');
                            if (includeFamilyLabel) {
                                addLine(xmlParts, 2, `<label>${familyLabel}</label>`);
                            }
                            addLine(xmlParts, 2, '<attributes>');

                            const attributeCodes = family.attributes ? family.attributes.split(',').map(c => c.trim()) : [];

                            for (const attrCode of attributeCodes) {
                                if (!attrCode) continue;

                                const attribute = findAttributeByCode(attrCode);
                                if (!attribute) {
                                    logAttributeIssue(attrCode, 'Attribute not found in attributeMap (simple XML)');
                                    continue;
                                }

                                const group = (attribute.group || '').trim().toLowerCase();
                                if (EXCLUDED_GROUPS.has(group)) {
                                    continue;
                                }

                                const attrLabelRaw = normalizeLabel(getAttributeLabel(attribute));
                                if (EXCLUDED_ATTRIBUTE_LABELS.has(attrLabelRaw.toLowerCase())) {
                                    continue;
                                }
                                const attrLabel = escapeXml(attrLabelRaw || attrCode);
                                const attrTypeValue = getAttributeType(attribute);
                                if (!attrTypeValue) {
                                    logAttributeIssue(attrCode, 'Attribute type is empty (simple XML)', attribute);
                                }
                                const attrTypeLabel = getAttributeTypeLabel(attrTypeValue) || attrTypeValue || '';
                                if (attrTypeLabel === '' || attrTypeLabel === attrTypeValue && !ATTRIBUTE_TYPE_LABELS[attrTypeValue]) {
                                    logAttributeIssue(attrCode, 'Attribute type label not mapped (simple XML)', attribute);
                                }
                                const values = findValuesByAttributeCode(attrCode);
                                appendExportRows(family, attribute, values);
                                let attributeLine = '<attribute';
                                if (includeAttributeLabel) {
                                    attributeLine += ` label="${attrLabel}"`;
                                }
                                if (includeAttributeType && attrTypeLabel) {
                                    attributeLine += ` type="${escapeXml(attrTypeLabel)}"`;
                                }
                                attributeLine += ' />';
                                addLine(xmlParts, 3, attributeLine);
                            }

                            addLine(xmlParts, 2, '</attributes>');
                            addLine(xmlParts, 1, '</family>');
                            if (currentIndex + 1 < totalFamilies) {
                                addLine(xmlParts, 0, '');
                            }

                            currentIndex++;
                            updateProgress(currentIndex, totalFamilies, `Обробка фемілії ${currentIndex} з ${totalFamilies}...`);
                        }

                        if (currentIndex < totalFamilies) {
                            setTimeout(processBatch, 0);
                        } else {
                            addLine(xmlParts, 0, '</families>');
                            updateProgress(totalFamilies, totalFamilies, `Оброблено ${totalFamilies} з ${totalFamilies}. Завершення...`);
                            resolve(xmlParts);
                        }
                    };

                    updateProgress(0, totalFamilies, `Обробка фемілії 0 з ${totalFamilies}...`);
                    processBatch();
                } catch (error) {
                    reject(new Error('Помилка генерації XML: ' + error.message));
                }
            });
        }

        async function startGeneration(generatorFn, fileName) {
            const progressContainer = document.getElementById('progressContainer');
            const generateBtn = document.getElementById('generateBtn');
            const preview = document.getElementById('preview');
            const xmlContent = document.getElementById('xmlContent');

            try {
                const families = getFilteredFamilies();
                if (!families.length) {
                    showError('Оберіть щонайменше одну фемілію для генерації');
                    return;
                }
                activeFamilies = families;
                progressContainer.classList.add('show');
                generateBtn.disabled = true;
                downloadBtn.disabled = true;
                downloadCsvBtn.disabled = true;
                downloadXlsxBtn.disabled = true;

                generatedXMLBlob = null;
                generatedXMLFileName = fileName || 'output.xml';
                xmlContent.textContent = '';
                preview.classList.remove('show');
                exportRows = [];

                const xmlParts = await generatorFn();
                const previewText = buildPreviewText(xmlParts);
                generatedXMLBlob = new Blob(xmlParts, { type: 'text/xml;charset=utf-8' });
                xmlContent.textContent = previewText || '(попередній перегляд недоступний)';
                preview.classList.add('show');
                xmlParts.length = 0;
                downloadBtn.disabled = false;
                generateBtn.disabled = false;
                progressContainer.classList.remove('show');
                updateExportButtonsState();
                showSuccess('Успішно згенеровано!');
            } catch (error) {
                generateBtn.disabled = false;
                progressContainer.classList.remove('show');
                showError(error.message);
            } finally {
                activeFamilies = [];
            }
        }

        updateExportButtonsState();
        renderSettingsControls();
        renderFamilyList();
        updateFamilySelectionInfo();

        if (familySearchInput) {
            familySearchInput.addEventListener('input', (e) => {
                familySearchTerm = e.target.value.trim().toLowerCase();
                renderFamilyList();
            });
        }

        if (familySelectAllBtn) {
            familySelectAllBtn.addEventListener('click', () => {
                if (!familyListData.length) return;
                selectedFamilyCodes = new Set(familyListData.map(item => item.code));
                renderFamilyList();
                updateFamilySelectionInfo();
                updateEmbeddedOutputs();
            });
        }

        if (familyClearBtn) {
            familyClearBtn.addEventListener('click', () => {
                selectedFamilyCodes.clear();
                renderFamilyList();
                updateFamilySelectionInfo();
                updateEmbeddedOutputs();
            });
        }

        if (settingsSelectAllBtn) {
            settingsSelectAllBtn.addEventListener('click', () => {
                EXPORT_COLUMNS.forEach(col => {
                    exportSettings[col.key] = true;
                });
                renderSettingsControls();
                updateExportButtonsState();
            });
        }

        if (settingsClearBtn) {
            settingsClearBtn.addEventListener('click', () => {
                EXPORT_COLUMNS.forEach(col => {
                    exportSettings[col.key] = false;
                });
                renderSettingsControls();
                updateExportButtonsState();
            });
        }

        if (loginForm) {
            loginForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const username = (usernameInput.value || '').trim();
                const password = (passwordInput.value || '').trim();
                const account = USERS.find(user => user.username === username && user.password === password);
                if (!account) {
                    loginError.textContent = 'Невірний логін або пароль';
                    return;
                }
                loginError.textContent = '';
                currentRole = account.role;
                document.body.classList.add('authenticated');
                document.body.classList.toggle('partner-role', currentRole === 'partner');
                document.body.classList.toggle('admin-role', currentRole === 'admin');
                initializeData();
            });
        }

        document.getElementById('familyFile').addEventListener('change', async (e) => {
            try {
                const fileName = e.target.files[0]?.name || DEFAULT_FILE_PLACEHOLDER;
                document.getElementById('familyFileName').textContent = fileName;
                familyData = await handleFileUpload(
                    e.target,
                    document.getElementById('familyStatus'),
                    'familyData'
                );
                checkAllFilesLoaded();
                prepareFamilySelection();
            } catch (error) {
                showError('Помилка завантаження файлу фемілі: ' + error.message);
            }
        });

        document.getElementById('attributesFile').addEventListener('change', async (e) => {
            try {
                const fileName = e.target.files[0]?.name || DEFAULT_FILE_PLACEHOLDER;
                document.getElementById('attributesFileName').textContent = fileName;
                attributesData = await handleFileUpload(
                    e.target,
                    document.getElementById('attributesStatus'),
                    'attributesData'
                );
                checkAllFilesLoaded();
            } catch (error) {
                showError('Помилка завантаження файлу атрибутів: ' + error.message);
            }
        });

        document.getElementById('valuesFile').addEventListener('change', async (e) => {
            try {
                const fileName = e.target.files[0]?.name || DEFAULT_FILE_PLACEHOLDER;
                document.getElementById('valuesFileName').textContent = fileName;
                valuesData = await handleFileUpload(
                    e.target,
                    document.getElementById('valuesStatus'),
                    'valuesData'
                );
                checkAllFilesLoaded();
            } catch (error) {
                showError('Помилка завантаження файлу значень: ' + error.message);
            }
        });

        document.getElementById('generateBtn').addEventListener('click', () => {
            startGeneration(generateXML, 'families-full.xml');
        });

        downloadBtn.addEventListener('click', () => {
            if (!generatedXMLBlob) {
                showError('Спочатку згенеруйте XML');
                return;
            }

            triggerDownload(generatedXMLBlob, generatedXMLFileName || 'output.xml');
            showSuccess('XML файл завантажено!');
        });

        downloadCsvBtn.addEventListener('click', downloadCsvFile);
        downloadXlsxBtn.addEventListener('click', downloadXlsxFile);
        if (saveEmbeddedBtn) {
            saveEmbeddedBtn.addEventListener('click', downloadEmbeddedDataFile);
        }
    </script>
</body>

</html>
